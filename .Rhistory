max.norm.M <- birds$Medium.dependency/max(birds$Medium.dependency)
max.norm.H <- birds$High.Dependency/max(birds$High.Dependency)
plot(birds$altitude, max.norm.M, xlab="Altitude (mètres)", ylab="Abondance d'oiseaux\n(Richesse)",
main="", pch =15, col="darkgreen", ylim=range(c(max.norm.M,max.norm.H)))
points(birds$altitude, max.norm.H, pch=16, col="gold")
# Ajouter la légende.
legend("bottomleft", legend = c("Moyenne", "Élevée"), title="Niveau de Dépendance", pch=c(15,16), col=c("darkgreen", "gold"), bty="n")
layout(matrix(c(1:4), nrow=1, byrow = T))
Etude <- birds$altitude
Colombie <- c(rnorm(250, 2000, 700))
hist(Etude, main="Fonction de densité (Etude, X)", xlab="altitude")
qqnorm(Etude)
qqline(Etude)
hist(Colombie, main="Fonction de densité (Colombie, Y)", xlab="altitude")
qqnorm(Colombie)
qqline(Colombie)
shapiro.test(Etude)
shapiro.test(Colombie)
boxplot(Etude, Colombie, names = c("Etude (E)", "Colombie (P)"), ylab="Altitude",
xlab="Echantillon versus Population", col=c("firebrick", "cornflowerblue"))
legend("topleft", legend = c(round(sd(Etude), 0),round(sd(Colombie), 0)), fill=c("firebrick", "cornflowerblue"), bty="n", cex=0.8, title = "écart-types")
var.test(Etude, Colombie)
n_x <- length(Etude) # on enregistre le nombre d'observations dans X
n_y <- length(Colombie) # on enregistre le nombre d'observations dans Y
## On calcul les variances
var_x <- var(Etude) # on enregistre la variance de X
var_y <- var(Colombie) # on enregistre la variance de Y
## On calcul les moyennes
mu_x <- mean(Etude)
mu_y <- mean(Colombie)
## On calcul la variance poolée
S2_P <- ((n_x-1)*var_x + (n_y-1)*var_y)/(n_x+n_y-2)
## On peut finalement calculer la Statistique T
S_T = (mu_x-mu_y) / sqrt(S2_P/(n_x-1) + S2_P/(n_y-1))
print(S_T)
loi_de_student <- rt(500, 270)
hist(loi_de_student, main="Densité d'une loi de Student", xlab="") # On construit une loi de student pour replacer notre statistique de T et calculer sa probabilité (i.e. sa rareté).
abline(v=S_T)
text(x=S_T+0.25,y=50 , "Statistique T\nde notre test", adj=0, xpd="NA")
length(which(loi_de_student>S_T))/500
## On peut aussi calculer la probabilité d'observer la statistique T calculée directement avec la fonction de probabilité.
1-pt(S_T ,270)
t.test(Etude, Colombie, var.equal = T)
Colombian_birds <- (birds$Medium.dependency+birds$High.Dependency)+rnorm(22,0, 1)
French_birds <- c(rnorm(10, 200, 50),rnorm(10, 250, 10))
df <- data.frame(Pays = c(rep("Colombie", length(Colombian_birds)),rep("France", length(French_birds))) ,
diversity = c(Colombian_birds, French_birds))
R_x <- sum(rank(df$diversity)[which(df$Pays=="France")]) # On récupère la somme des rangs associées au oiseaux de la France.
paste('la statistique du test de wilcoxon est de : w = ',22*20+((20*(20+1))/2)-R_x)
wilcox.test(diversity~Pays, data=df)
wilcox.test(df$value~df$Group)
load(file = "data/Birds_dataset.rda")
knitr::kable(head(birds))
# Représenter la variable d'altitude.
hist(birds$altitude, col="lightblue", xlab="Altitude (mètres)",ylim=c(0,8),
ylab="Comptage", main="Histogramme de l'altitude des sites")
# Représentation du paramètre de position.
abline(v=mean(birds$altitude), col='red', lwd=2)
abline(v=median(birds$altitude), col="blue", lwd=2)
# Représentation du paramètre de dispersion.
segments(x0 = mean(birds$altitude) - sd(birds$altitude),
x1 = mean(birds$altitude) + sd(birds$altitude),
y0 = 7.5, col="darkolivegreen", lwd=2)
# On ajoute une légende pour comprendre notre graphique.
legend("topleft", col=c("darkolivegreen","red","blue"), lty=1, legend = c("sd", "mean", "median"),
lwd=2, bty="n")
ecart_type <- sd(birds$altitude) # définir l'écart-type
condition_moins_ecartT <- which(birds$altitude < (mean(birds$altitude) + (2*ecart_type))) # renvoie l'ensemble des obsevrations pour lequel la condition suivant est respecté : obs INFÉRIEURE à la moyenne + ou - 2 SD.
condition_plus_ecartT <- which(birds$altitude > (mean(birds$altitude) + (2*ecart_type))) # renvoie l'ensemble des obsevrations pour lequel la condition suivant est respecté : obs SUPÉRIEURE à la moyenne + ou - 2 SD.
length(condition_moins_ecartT | condition_plus_ecartT) / # renvoie le nombre d'observation qui respecte les deux conditions précédentes.
length(birds$altitude) # diviser par le nombre total d'observations.
layout(matrix(c(1,2), nrow=1))
par(mar=c(5,5,2,2)) # Gérer les marges du plot.
# PLOT N°1
boxplot(birds$Medium.dependency,birds$High.Dependency, names = c("Moyenne", 'Élevée'), xlab='Niveau de dependance',
ylab="Richesse d'oiseaux (diversité)")
# PLOT N°2
plot(birds$altitude, birds$Medium.dependency+birds$High.Dependency,
xlab="Altitude (mètres)", ylab="Abondance d'oiseaux\n(Richesse)", main="")
par(mar=c(5,5,2,2)) # Gérer les marges du plot.
# Il faut d'abord normaliser les données pour pouvoir les comparer entre elles
# Plusieurs normalisation existe, ici nous normaliserons les données par rapport à leur maximum.
max.norm.M <- birds$Medium.dependency/max(birds$Medium.dependency)
max.norm.H <- birds$High.Dependency/max(birds$High.Dependency)
plot(birds$altitude, max.norm.M, xlab="Altitude (mètres)", ylab="Abondance d'oiseaux\n(Richesse)",
main="", pch =15, col="darkgreen", ylim=range(c(max.norm.M,max.norm.H)))
points(birds$altitude, max.norm.H, pch=16, col="gold")
# Ajouter la légende.
legend("bottomleft", legend = c("Moyenne", "Élevée"), title="Niveau de Dépendance", pch=c(15,16), col=c("darkgreen", "gold"), bty="n")
layout(matrix(c(1:4), nrow=1, byrow = T))
Etude <- birds$altitude
Colombie <- c(rnorm(250, 2000, 700))
hist(Etude, main="Fonction de densité (Etude, X)", xlab="altitude")
qqnorm(Etude)
qqline(Etude)
hist(Colombie, main="Fonction de densité (Colombie, Y)", xlab="altitude")
qqnorm(Colombie)
qqline(Colombie)
shapiro.test(Etude)
shapiro.test(Colombie)
boxplot(Etude, Colombie, names = c("Etude (E)", "Colombie (P)"), ylab="Altitude",
xlab="Echantillon versus Population", col=c("firebrick", "cornflowerblue"))
legend("topleft", legend = c(round(sd(Etude), 0),round(sd(Colombie), 0)), fill=c("firebrick", "cornflowerblue"), bty="n", cex=0.8, title = "écart-types")
var.test(Etude, Colombie)
n_x <- length(Etude) # on enregistre le nombre d'observations dans X
n_y <- length(Colombie) # on enregistre le nombre d'observations dans Y
## On calcul les variances
var_x <- var(Etude) # on enregistre la variance de X
var_y <- var(Colombie) # on enregistre la variance de Y
## On calcul les moyennes
mu_x <- mean(Etude)
mu_y <- mean(Colombie)
## On calcul la variance poolée
S2_P <- ((n_x-1)*var_x + (n_y-1)*var_y)/(n_x+n_y-2)
## On peut finalement calculer la Statistique T
S_T = (mu_x-mu_y) / sqrt(S2_P/(n_x-1) + S2_P/(n_y-1))
print(S_T)
loi_de_student <- rt(500, 270)
hist(loi_de_student, main="Densité d'une loi de Student", xlab="") # On construit une loi de student pour replacer notre statistique de T et calculer sa probabilité (i.e. sa rareté).
abline(v=S_T)
text(x=S_T+0.25,y=50 , "Statistique T\nde notre test", adj=0, xpd="NA")
length(which(loi_de_student>S_T))/500
## On peut aussi calculer la probabilité d'observer la statistique T calculée directement avec la fonction de probabilité.
1-pt(S_T ,270)
t.test(Etude, Colombie, var.equal = T)
Colombian_birds <- (birds$Medium.dependency+birds$High.Dependency)+rnorm(22,0, 1)
French_birds <- c(rnorm(10, 200, 50),rnorm(10, 250, 10))
df <- data.frame(Pays = c(rep("Colombie", length(Colombian_birds)),rep("France", length(French_birds))) ,
diversity = c(Colombian_birds, French_birds))
R_x <- sum(rank(df$diversity)[which(df$Pays=="France")]) # On récupère la somme des rangs associées au oiseaux de la France.
paste('la statistique du test de wilcoxon est de : w = ',22*20+((20*(20+1))/2)-R_x)
wilcox.test(diversity~Pays, data=df)
set.seed(1)
boxplot(rnorm(10), rnorm(10, 0.5))
set.seed(1)
df = data.frame(Group = rep(c(1,2), each = 5), value = c(rnorm(5), rnorm(5, 01.1)))
plot(df$Group, df$value, xlab="", ylab="")
rank(df$value)[which(df$Group==1)]
paste("la somme des rangs pour le groupe 1 est de", sum(rank(df$value)[which(df$Group==1)]))
rank(df$value)[which(df$Group==1)]
paste("la somme des rangs pour le groupe 1 est de", sum(rank(df$value)[which(df$Group==1)]))
wilcox.test(df$value~df$Group)
rank(df$value)[which(df$Group==1)]
paste("la somme des rangs pour le groupe 1 est de", sum(rank(df$value)[which(df$Group==1)]))
wilcox.test(df$value~df$Group)
df <- read.table("~/Dropbox/COURS/UBS/BIO1540/Package n°2/rawdata/heptathlon_2023.csv", sep=",", header=T, stringsAsFactors = T, row.names = 1)
df <- read.table("data/heptathlon_2023.csv", sep=",", header=T, stringsAsFactors = T, row.names = 1)
df <- read.table("data/heptathlon_2023.csv", sep=",", header=T, stringsAsFactors = T, row.names = 1)
layout(matrix(c(1,2), nrow=1))
plot(df$X100m, df$X200m, xlab="100H (s)", ylab="200 (s)", pch=16, col="gray")
plot(df$Longueur, df$X200m,  xlab="Longueur (m)", ylab="200 (s)", pch=16, col="gray")
df <- read.table("data/heptathlon_2023.csv", sep=",", header=T, stringsAsFactors = T, row.names = 1)
head(df)
n <- dim(df)[1]
x_center <- df$X100m-mean(df$X100m)
y_center <- df$X200m-mean(df$X200m)
Covariance <- sum(x_center*y_center)/(n-1)
var_x <- sqrt(sum(x_center^2)/(n-1))
var_y <- sqrt(sum(y_center^2)/(n-1))
r <- Covariance/(var_x*var_y)
print(r)
lm(df$X200m~df$X100m)
lm(df$X200m~df$X100m)
lm(df$X200m~df$X100m)
plot(df$X100m, df$X200m, xlab="100H (s)", ylab="200 (s)", pch=16, col="gray")
points(df$X100m[which(df$X100m>15)],df$X200m[which(df$X100m>15)], col="red", pch=16)
abline(coef(lm(df$X200m~df$X100m)))
plot(df$X100m, df$X200m, xlab="100H (s)", ylab="200 (s)", pch=16, col="gray")
points(df$X100m[which(df$X100m>15)],df$X200m[which(df$X100m>15)], col="red", pch=16)
abline(coef(lm(df$X200m~df$X100m)))
plot(df$X100m, df$X200m, xlab="100H (s)", ylab="200 (s)", pch=16, col="gray")
points(df$X100m[which(df$X100m>15)],df$X200m[which(df$X100m>15)], col="red", pch=16)
abline(coef(lm(df$X200m~df$X100m)))
lm(df$X200m~df$X100m)
model <- lm(df$X200m~df$X100m) ## Nous ajustons un modèle linéaire où la variable réponse est le temps au 200m.
SCT = sum(y_center^2) ## Nous calculons la somme des carrés totale de la variable réponse Y.
SCE = sum(model$residuals^2) ## Puis la somme des carrés non expliquée de la variable réponse Y par X.
r_squared <- 1-(SCE/SCT)
print(r_squared)
r^2
model <- lm(df$X200m~df$X100m)
summary(model)
cor.test(df$X200m,df$X100m, method="pearson")
shapiro.test(df$X100m)
shapiro.test(df$X200m)
df <- read.table("data/heptathlon_2023.csv", sep=",", header=T, stringsAsFactors = T, row.names = 1)
df <- read.table("data/heptathlon_2023.csv", sep=",", header=T, stringsAsFactors = T, row.names = 1)
head(df)
layout(matrix(c(1,2), nrow=1))
plot(df$X100m, df$X200m, xlab="100H (s)", ylab="200 (s)", pch=16, col="gray")
plot(df$Longueur, df$X200m,  xlab="Longueur (m)", ylab="200 (s)", pch=16, col="gray")
plot(df$X100m, df$X200m, xlab="100H (s)", ylab="200 (s)", pch=16, col="gray")
points(df$X100m[which(df$X100m>15)],df$X200m[which(df$X100m>15)], col="red", pch=16)
abline(coef(lm(df$X200m~df$X100m)))
df <- read.table("data/SHN-microbiote.csv", sep=",", header=T, stringsAsFactors = T, encoding = 'latin1', row.names=1)
colnames(df)
knitr::kable(table(df))
SHN_NA <- c(sum(df$SHN==TRUE),sum(df$SHN==FALSE)) ## (1) Faire la somme des SHN et NA, peu importe le type de microbiote intestinal et (2) l'enregister dans un nouvel objet R.
par(mar=c(0,0,0,0)) # Permet de conditionner les marges du plot.
pie(SHN_NA, labels = c("SHN", "NA"), col=c("firebrick","cornflowerblue")) ## Utiliser la fonction pie.
df.proportion.Sport <- apply(table(df), 2, function(x) {x/sum(x)}) # je calcul les proportions en ligne.
df.proportion.Microbiote <- apply(table(df), 1, function(x) {x/sum(x)}) # je calcul les proportions en colonne.
layout(matrix(c(1,2,3), nrow=1)) # permet de réaliser une fenêtre graphique à 3 cases
barplot(as.matrix(df.proportion.Sport), col=c("firebrick","cornflowerblue"), xlab="Type de Microbiote") # premier plot
barplot(as.matrix(df.proportion.Microbiote), col=c("darkgreen","green"), xlab="Sports")  # second plot
plot.new() # j'ajoute un troisième plot vide pour pouvoir placer la légende.
legend("center",c('SHN', 'NA', "Type 1", "Type 2"),
fill=c("firebrick","cornflowerblue","darkgreen","green"), bty="n")
print(chisq.test(df$SHN, df$Enterotype))
# Représenter la variable d'altitude.
hist(birds$altitude, col="lightblue", xlab="Altitude (mètres)",ylim=c(0,8),
ylab="Comptage", main="Histogramme de l'altitude des sites")
load(file = "data/Birds_dataset.rda")
knitr::kable(head(birds))
# Représenter la variable d'altitude.
hist(birds$altitude, col="lightblue", xlab="Altitude (mètres)",ylim=c(0,8),
ylab="Comptage", main="Histogramme de l'altitude des sites")
# Représentation du paramètre de position.
abline(v=mean(birds$altitude), col='red', lwd=2)
abline(v=median(birds$altitude), col="blue", lwd=2)
# Représentation du paramètre de dispersion.
segments(x0 = mean(birds$altitude) - sd(birds$altitude),
x1 = mean(birds$altitude) + sd(birds$altitude),
y0 = 7.5, col="darkolivegreen", lwd=2)
# On ajoute une légende pour comprendre notre graphique.
legend("topleft", col=c("darkolivegreen","red","blue"), lty=1, legend = c("sd", "mean", "median"),
lwd=2, bty="n")
ecart_type <- sd(birds$altitude) # définir l'écart-type
condition_moins_ecartT <- which(birds$altitude < (mean(birds$altitude) + (2*ecart_type))) # renvoie l'ensemble des obsevrations pour lequel la condition suivant est respecté : obs INFÉRIEURE à la moyenne + ou - 2 SD.
condition_plus_ecartT <- which(birds$altitude > (mean(birds$altitude) + (2*ecart_type))) # renvoie l'ensemble des obsevrations pour lequel la condition suivant est respecté : obs SUPÉRIEURE à la moyenne + ou - 2 SD.
length(condition_moins_ecartT | condition_plus_ecartT) / # renvoie le nombre d'observation qui respecte les deux conditions précédentes.
length(birds$altitude) # diviser par le nombre total d'observations.
layout(matrix(c(1,2), nrow=1))
par(mar=c(5,5,2,2)) # Gérer les marges du plot.
# PLOT N°1
boxplot(birds$Medium.dependency,birds$High.Dependency, names = c("Moyenne", 'Élevée'), xlab='Niveau de dependance',
ylab="Richesse d'oiseaux (diversité)")
# PLOT N°2
plot(birds$altitude, birds$Medium.dependency+birds$High.Dependency,
xlab="Altitude (mètres)", ylab="Abondance d'oiseaux\n(Richesse)", main="")
par(mar=c(5,5,2,2)) # Gérer les marges du plot.
# Il faut d'abord normaliser les données pour pouvoir les comparer entre elles
# Plusieurs normalisation existe, ici nous normaliserons les données par rapport à leur maximum.
max.norm.M <- birds$Medium.dependency/max(birds$Medium.dependency)
max.norm.H <- birds$High.Dependency/max(birds$High.Dependency)
plot(birds$altitude, max.norm.M, xlab="Altitude (mètres)", ylab="Abondance d'oiseaux\n(Richesse)",
main="", pch =15, col="darkgreen", ylim=range(c(max.norm.M,max.norm.H)))
points(birds$altitude, max.norm.H, pch=16, col="gold")
# Ajouter la légende.
legend("bottomleft", legend = c("Moyenne", "Élevée"), title="Niveau de Dépendance", pch=c(15,16), col=c("darkgreen", "gold"), bty="n")
X <- cbind(c(rnorm(30, mean=0, sd=1), rnorm(30, 4, 0.5)),
c(rnorm(30, mean=0, sd=1), rnorm(30, 2, 1)))
plot(X, xlab="ASAT", ylab="ALAT", pch=16, col="firebrick")
plot(X, xlab="ASAT", ylab="ALAT", pch=16, col="firebrick")
points(x=X[24,1], y=X[24,2], xlab="ASAT", ylab="ALAT", pch=16, col="cornflowerblue")
points(x=X[4,1], y=X[4,2], xlab="ASAT", ylab="ALAT", pch=16, col="gold")
## ASSIGNATION
d_n_blue <- as.matrix(dist(rbind(X[24,],X)))[-1,1] # Distance de l'ensemble des points au point bleu.
d_n_gold <- as.matrix(dist(rbind(X[4,],X)))[-1,1] # Distance de l'ensemble des points au point jaune.
cluster <- apply(cbind(d_n_blue, d_n_gold),1,which.min) # phase d'assignation.
cluster_col <- as.character(factor(cluster, c(1,2), c("cornflowerblue", "gold")))
layout(matrix(c(1,2), nrow=1))
plot(X, xlab="ASAT", ylab="ALAT", pch=1, col=cluster_col)
points(x=X[24,1], y=X[24,2], xlab="ASAT", ylab="ALAT", pch=16, col="cornflowerblue")
points(x=X[4,1], y=X[4,2], xlab="ASAT", ylab="ALAT", pch=16, col="gold")
## NOUVEAUX CENTROÏDES
centroide_blue <- colMeans(X[which(cluster==1),])
centroide_jaune <- colMeans(X[which(cluster==2),])
plot(X, xlab="ASAT", ylab="ALAT", pch=1, col="firebrick")
points(x=X[24,1], y=X[24,2], xlab="ASAT", ylab="ALAT", pch=16, col="cornflowerblue")
points(x=X[4,1], y=X[4,2], xlab="ASAT", ylab="ALAT", pch=16, col="gold")
points(centroide_blue[1], centroide_blue[2], xlab="ASAT", ylab="ALAT", pch=15, col="cornflowerblue")
points(centroide_jaune[1], centroide_jaune[2], xlab="ASAT", ylab="ALAT", pch=15, col="gold")
legend("topleft", c("1ere itération", "2nd itération"), bty="n", pch= c(16, 15))
## ASSIGNATION
d_n_blue <- as.matrix(dist(rbind(X[24,],X)))[-1,1] # Distance de l'ensemble des points au point bleu.
d_n_gold <- as.matrix(dist(rbind(X[4,],X)))[-1,1] # Distance de l'ensemble des points au point jaune.
cluster <- apply(cbind(d_n_blue, d_n_gold),1,which.min) # phase d'assignation.
cluster_col <- as.character(factor(cluster, c(1,2), c("cornflowerblue", "gold")))
plot(X, xlab = "ASAT", ylab = "ALAT", pch = 1, col = cluster_col, main = "Distances des points par rapport aux points initiaux")
points(x=X[24,1], y=X[24,2], xlab="ASAT", ylab="ALAT", pch=16, col="cornflowerblue")
points(x=X[4,1], y=X[4,2], xlab="ASAT", ylab="ALAT", pch=16, col="gold")
## NOUVEAUX CENTROÏDES
centroide_blue <- colMeans(X[which(cluster==1),])
centroide_jaune <- colMeans(X[which(cluster==2),])
plot(X, xlab="ASAT", ylab="ALAT", pch=1, col="firebrick")
points(x=X[24,1], y=X[24,2], xlab="ASAT", ylab="ALAT", pch=16, col="cornflowerblue")
points(x=X[4,1], y=X[4,2], xlab="ASAT", ylab="ALAT", pch=16, col="gold")
points(centroide_blue[1], centroide_blue[2], xlab="ASAT", ylab="ALAT", pch=15, col="cornflowerblue")
points(centroide_jaune[1], centroide_jaune[2], xlab="ASAT", ylab="ALAT", pch=15, col="gold")
legend("topleft", c("1ere itération", "2nd itération"), bty="n", pch= c(16, 15))
## NOUVEAUX CENTROÏDES
centroide_blue <- colMeans(X[which(cluster==1),])
centroide_jaune <- colMeans(X[which(cluster==2),])
plot(X, xlab="ASAT", ylab="ALAT", pch=1, col="firebrick")
points(x=X[24,1], y=X[24,2], xlab="ASAT", ylab="ALAT", pch=16, col="cornflowerblue")
points(x=X[4,1], y=X[4,2], xlab="ASAT", ylab="ALAT", pch=16, col="gold")
points(centroide_blue[1], centroide_blue[2], xlab="ASAT", ylab="ALAT", pch=15, col="cornflowerblue")
points(centroide_jaune[1], centroide_jaune[2], xlab="ASAT", ylab="ALAT", pch=15, col="gold")
legend("topleft", c("1ere itération", "2nd itération"), bty="n", pch= c(16, 15), title = "Centres de gravité (nuage de points)")
d_n_blue <- as.matrix(dist(rbind(centroide_blue,X)))[-1,1] # Distance de l'ensemble des points au carré bleu.
d_n_gold <- as.matrix(dist(rbind(centroide_jaune,X)))[-1,1] # Distance de l'ensemble des points au carré jaune.
cluster <- apply(cbind(d_n_blue, d_n_gold),1,which.min) # phase d'assignation.
cluster_col <- as.character(factor(cluster, c(1,2), c("cornflowerblue", "gold")))
layout(matrix(c(1,2), nrow=1))
plot(X, xlab="ASAT", ylab="ALAT", pch=1, col=cluster_col)
points(centroide_blue[1], centroide_blue[2], xlab="ASAT", ylab="ALAT", pch=15, col="cornflowerblue")
points(centroide_jaune[1], centroide_jaune[2], xlab="ASAT", ylab="ALAT", pch=15, col="gold")
## NOUVEAUX CENTROÏDES
centroide_blue_2 <- colMeans(X[which(cluster==1),])
centroide_jaune_2 <- colMeans(X[which(cluster==2),])
plot(X, xlab="ASAT", ylab="ALAT", pch=1, col="firebrick")
points(centroide_blue[1], centroide_blue[2],pch=15, col="cornflowerblue")
points(centroide_jaune[1], centroide_jaune[2],  pch=15, col="gold")
points(centroide_blue_2[1], centroide_blue_2[2],pch=17, col="cornflowerblue")
points(centroide_jaune_2[1], centroide_jaune_2[2], pch=17, col="gold")
legend("topleft", c("2nd itération", "3eme itération"), bty="n", pch= c(15,17))
d_n_blue <- as.matrix(dist(rbind(centroide_blue,X)))[-1,1] # Distance de l'ensemble des points au carré bleu.
d_n_gold <- as.matrix(dist(rbind(centroide_jaune,X)))[-1,1] # Distance de l'ensemble des points au carré jaune.
cluster <- apply(cbind(d_n_blue, d_n_gold),1,which.min) # phase d'assignation.
cluster_col <- as.character(factor(cluster, c(1,2), c("cornflowerblue", "gold")))
layout(matrix(c(1,2), nrow=1))
plot(X, xlab="ASAT", ylab="ALAT", pch=1, col=cluster_col, main = "ASSIGNATION")
points(centroide_blue[1], centroide_blue[2], xlab="ASAT", ylab="ALAT", pch=15, col="cornflowerblue")
points(centroide_jaune[1], centroide_jaune[2], xlab="ASAT", ylab="ALAT", pch=15, col="gold")
## NOUVEAUX CENTROÏDES
centroide_blue_2 <- colMeans(X[which(cluster==1),])
centroide_jaune_2 <- colMeans(X[which(cluster==2),])
plot(X, xlab="ASAT", ylab="ALAT", pch=1, col="firebrick", main = "NOUVEAUX CENTROÏDES")
points(centroide_blue[1], centroide_blue[2],pch=15, col="cornflowerblue")
points(centroide_jaune[1], centroide_jaune[2],  pch=15, col="gold")
points(centroide_blue_2[1], centroide_blue_2[2],pch=17, col="cornflowerblue")
points(centroide_jaune_2[1], centroide_jaune_2[2], pch=17, col="gold")
legend("topleft", c("2nd itération", "3eme itération"), bty="n", pch= c(15,17))
## ASSIGNATION FINALE
d_n_blue <- as.matrix(dist(rbind(centroide_blue_2,X)))[-1,1] # Distance de l'ensemble des points au point bleu.
d_n_gold <- as.matrix(dist(rbind(centroide_jaune_2,X)))[-1,1] # Distance de l'ensemble des points au point jaune.
cluster <- apply(cbind(d_n_blue, d_n_gold),1,which.min) # phase d'assignation.
cluster_col <- as.character(factor(cluster, c(1,2), c("cornflowerblue", "gold")))
plot(X, xlab="ASAT", ylab="ALAT", pch=1, col=cluster_col)
points(centroide_blue_2[1], centroide_blue_2[2],pch=17, col="cornflowerblue")
points(centroide_jaune_2[1], centroide_jaune_2[2], pch=17, col="gold")
res.kmeans <- kmeans(X, centers = 2, iter.max = 1, nstart = 1)
res.kmeans
res.kmeans$centers
res.kmeans$cluster
res.kmeans$centers
res.kmeans$cluster
X <- data.frame(ASAT = c(rnorm(30, mean=0, sd=1), rnorm(30, 4, 0.5)),
ALAT = c(rnorm(30, mean=0, sd=1), rnorm(30, 2, 1)))
plot(X, xlab="ASAT", ylab="ALAT", pch=16, col="firebrick")
plot(X, xlab="ASAT", ylab="ALAT", pch=16, col="firebrick")
points(x=X[24,1], y=X[24,2], xlab="ASAT", ylab="ALAT", pch=16, col="cornflowerblue")
points(x=X[4,1], y=X[4,2], xlab="ASAT", ylab="ALAT", pch=16, col="gold")
## ASSIGNATION
d_n_blue <- as.matrix(dist(rbind(X[24,],X)))[-1,1] # Distance de l'ensemble des points au point bleu.
d_n_gold <- as.matrix(dist(rbind(X[4,],X)))[-1,1] # Distance de l'ensemble des points au point jaune.
cluster <- apply(cbind(d_n_blue, d_n_gold),1,which.min) # phase d'assignation.
cluster_col <- as.character(factor(cluster, c(1,2), c("cornflowerblue", "gold")))
plot(X, xlab = "ASAT", ylab = "ALAT", pch = 1, col = cluster_col, main = "Distances des points par rapport aux points initiaux")
points(x=X[24,1], y=X[24,2], xlab="ASAT", ylab="ALAT", pch=16, col="cornflowerblue")
points(x=X[4,1], y=X[4,2], xlab="ASAT", ylab="ALAT", pch=16, col="gold")
## NOUVEAUX CENTROÏDES
centroide_blue <- colMeans(X[which(cluster==1),])
centroide_jaune <- colMeans(X[which(cluster==2),])
plot(X, xlab="ASAT", ylab="ALAT", pch=1, col="firebrick")
points(x=X[24,1], y=X[24,2], xlab="ASAT", ylab="ALAT", pch=16, col="cornflowerblue")
points(x=X[4,1], y=X[4,2], xlab="ASAT", ylab="ALAT", pch=16, col="gold")
points(centroide_blue[1], centroide_blue[2], xlab="ASAT", ylab="ALAT", pch=15, col="cornflowerblue")
points(centroide_jaune[1], centroide_jaune[2], xlab="ASAT", ylab="ALAT", pch=15, col="gold")
legend("topleft", c("1ere itération", "2nd itération"), bty="n", pch= c(16, 15), title = "Centres de gravité (nuage de points)")
d_n_blue <- as.matrix(dist(rbind(centroide_blue,X)))[-1,1] # Distance de l'ensemble des points au carré bleu.
d_n_gold <- as.matrix(dist(rbind(centroide_jaune,X)))[-1,1] # Distance de l'ensemble des points au carré jaune.
cluster <- apply(cbind(d_n_blue, d_n_gold),1,which.min) # phase d'assignation.
cluster_col <- as.character(factor(cluster, c(1,2), c("cornflowerblue", "gold")))
layout(matrix(c(1,2), nrow=1))
plot(X, xlab="ASAT", ylab="ALAT", pch=1, col=cluster_col, main = "ASSIGNATION")
points(centroide_blue[1], centroide_blue[2], xlab="ASAT", ylab="ALAT", pch=15, col="cornflowerblue")
points(centroide_jaune[1], centroide_jaune[2], xlab="ASAT", ylab="ALAT", pch=15, col="gold")
## NOUVEAUX CENTROÏDES
centroide_blue_2 <- colMeans(X[which(cluster==1),])
centroide_jaune_2 <- colMeans(X[which(cluster==2),])
plot(X, xlab="ASAT", ylab="ALAT", pch=1, col="firebrick", main = "NOUVEAUX CENTROÏDES")
points(centroide_blue[1], centroide_blue[2],pch=15, col="cornflowerblue")
points(centroide_jaune[1], centroide_jaune[2],  pch=15, col="gold")
points(centroide_blue_2[1], centroide_blue_2[2],pch=17, col="cornflowerblue")
points(centroide_jaune_2[1], centroide_jaune_2[2], pch=17, col="gold")
legend("topleft", c("2nd itération", "3eme itération"), bty="n", pch= c(15,17))
## ASSIGNATION FINALE
d_n_blue <- as.matrix(dist(rbind(centroide_blue_2,X)))[-1,1] # Distance de l'ensemble des points au point bleu.
d_n_gold <- as.matrix(dist(rbind(centroide_jaune_2,X)))[-1,1] # Distance de l'ensemble des points au point jaune.
cluster <- apply(cbind(d_n_blue, d_n_gold),1,which.min) # phase d'assignation.
cluster_col <- as.character(factor(cluster, c(1,2), c("cornflowerblue", "gold")))
plot(X, xlab="ASAT", ylab="ALAT", pch=1, col=cluster_col)
points(centroide_blue_2[1], centroide_blue_2[2],pch=17, col="cornflowerblue")
points(centroide_jaune_2[1], centroide_jaune_2[2], pch=17, col="gold")
res.kmeans <- kmeans(X, centers = 2, iter.max = 1, nstart = 1)
# Utiliser le fonction help pour savoir à quoi corresponde les arguments de la fonction.
res.kmeans
res.kmeans$centers
res.kmeans$cluster
paste("ind",seq(1,60,1))
data.frame(paste("ind",seq(1,60,1)),res.kmeans$cluster)
head(data.frame(id = paste("ind",seq(1,60,1)), classe = res.kmeans$cluster))
res.kmeans$cluster
X <- data.frame(ASAT = c(rnorm(30, mean=0, sd=1), rnorm(30, 4, 1)),
ALAT = c(rnorm(30, mean=0, sd=1), rnorm(30, 2, 1)))
plot(X, xlab="ASAT", ylab="ALAT", pch=16, col="firebrick")
X <- data.frame(ASAT = c(rnorm(30, mean=0, sd=1), rnorm(30, 4, 1)),
ALAT = c(rnorm(30, mean=0, sd=1), rnorm(30, 2, 1)))
plot(X, xlab="ASAT", ylab="ALAT", pch=16, col="firebrick")
set.seed(1)
X <- data.frame(ASAT = c(rnorm(30, mean=0, sd=1), rnorm(30, 4, 1)),
ALAT = c(rnorm(30, mean=0, sd=1), rnorm(30, 2, 1)))
plot(X, xlab="ASAT", ylab="ALAT", pch=16, col="firebrick")
plot(X, xlab="ASAT", ylab="ALAT", pch=16, col="firebrick")
points(x=X[24,1], y=X[24,2], xlab="ASAT", ylab="ALAT", pch=16, col="cornflowerblue")
points(x=X[4,1], y=X[4,2], xlab="ASAT", ylab="ALAT", pch=16, col="gold")
## ASSIGNATION
d_n_blue <- as.matrix(dist(rbind(X[24,],X)))[-1,1] # Distance de l'ensemble des points au point bleu.
d_n_gold <- as.matrix(dist(rbind(X[4,],X)))[-1,1] # Distance de l'ensemble des points au point jaune.
cluster <- apply(cbind(d_n_blue, d_n_gold),1,which.min) # phase d'assignation.
cluster_col <- as.character(factor(cluster, c(1,2), c("cornflowerblue", "gold")))
plot(X, xlab = "ASAT", ylab = "ALAT", pch = 1, col = cluster_col, main = "Distances des points par rapport aux points initiaux")
points(x=X[24,1], y=X[24,2], xlab="ASAT", ylab="ALAT", pch=16, col="cornflowerblue")
points(x=X[4,1], y=X[4,2], xlab="ASAT", ylab="ALAT", pch=16, col="gold")
## NOUVEAUX CENTROÏDES
centroide_blue <- colMeans(X[which(cluster==1),])
centroide_jaune <- colMeans(X[which(cluster==2),])
plot(X, xlab="ASAT", ylab="ALAT", pch=1, col="firebrick")
points(x=X[24,1], y=X[24,2], xlab="ASAT", ylab="ALAT", pch=16, col="cornflowerblue")
points(x=X[4,1], y=X[4,2], xlab="ASAT", ylab="ALAT", pch=16, col="gold")
points(centroide_blue[1], centroide_blue[2], xlab="ASAT", ylab="ALAT", pch=15, col="cornflowerblue")
points(centroide_jaune[1], centroide_jaune[2], xlab="ASAT", ylab="ALAT", pch=15, col="gold")
legend("topleft", c("1ere itération", "2nd itération"), bty="n", pch= c(16, 15), title = "Centres de gravité (nuage de points)")
d_n_blue <- as.matrix(dist(rbind(centroide_blue,X)))[-1,1] # Distance de l'ensemble des points au carré bleu.
d_n_gold <- as.matrix(dist(rbind(centroide_jaune,X)))[-1,1] # Distance de l'ensemble des points au carré jaune.
cluster <- apply(cbind(d_n_blue, d_n_gold),1,which.min) # phase d'assignation.
cluster_col <- as.character(factor(cluster, c(1,2), c("cornflowerblue", "gold")))
layout(matrix(c(1,2), nrow=1))
plot(X, xlab="ASAT", ylab="ALAT", pch=1, col=cluster_col, main = "ASSIGNATION")
points(centroide_blue[1], centroide_blue[2], xlab="ASAT", ylab="ALAT", pch=15, col="cornflowerblue")
points(centroide_jaune[1], centroide_jaune[2], xlab="ASAT", ylab="ALAT", pch=15, col="gold")
## NOUVEAUX CENTROÏDES
centroide_blue_2 <- colMeans(X[which(cluster==1),])
centroide_jaune_2 <- colMeans(X[which(cluster==2),])
plot(X, xlab="ASAT", ylab="ALAT", pch=1, col="firebrick", main = "NOUVEAUX CENTROÏDES")
points(centroide_blue[1], centroide_blue[2],pch=15, col="cornflowerblue")
points(centroide_jaune[1], centroide_jaune[2],  pch=15, col="gold")
points(centroide_blue_2[1], centroide_blue_2[2],pch=17, col="cornflowerblue")
points(centroide_jaune_2[1], centroide_jaune_2[2], pch=17, col="gold")
legend("topleft", c("2nd itération", "3eme itération"), bty="n", pch= c(15,17))
## ASSIGNATION FINALE
d_n_blue <- as.matrix(dist(rbind(centroide_blue_2,X)))[-1,1] # Distance de l'ensemble des points au point bleu.
d_n_gold <- as.matrix(dist(rbind(centroide_jaune_2,X)))[-1,1] # Distance de l'ensemble des points au point jaune.
cluster <- apply(cbind(d_n_blue, d_n_gold),1,which.min) # phase d'assignation.
cluster_col <- as.character(factor(cluster, c(1,2), c("cornflowerblue", "gold")))
plot(X, xlab="ASAT", ylab="ALAT", pch=1, col=cluster_col)
points(centroide_blue_2[1], centroide_blue_2[2],pch=17, col="cornflowerblue")
points(centroide_jaune_2[1], centroide_jaune_2[2], pch=17, col="gold")
D <- dist(X) # Distance entre les individus.
HAC <- hclust(D, method = "ward.D") # Méthode d'agglomération.
layout(matrix(c(1,2), nrow=1))
plot(HAC)
groupe <- cutree(HAC, 2) # Assigner les groupes
plot(X, xlab="ASAT", ylab="ALAT", pch=16, col=groupe)
sigma <- matrix(0, ncol=2,nrow=2)
diag(sigma) <- c(1,0.4)
X <- rbind(mvtnorm::rmvnorm(100, mean=c(0,1.5), sigma),
mvtnorm::rmvnorm(100, mean=c(1,-2), sigma),
mvtnorm::rmvnorm(100, mean=c(-1,0), sigma))
layout(matrix(c(1,2), nrow=1))
plot(X[,c(1,2)], xlab ="x", ylab="y", pch=16)
plot(X[,c(1,2)], xlab ="x", ylab="y", col = rep(c("firebrick", "cornflowerblue", "purple"), each=100), pch=16)
var_intra = NULL
K = 2
res.class <- kmeans(X, centers = K)
plot(X, col=res.class$cluster, xlab="x",ylab="y" )
points(res.class$centers,pch=16, col=1:10)
for(k in 1:K){
var_intra <- c(var_intra, mean(as.matrix(dist(rbind(res.class$centers[k,],
X[which(res.class$cluster==k),])))[-1,1]))
}
legend("topright",paste("variance intra-classe", round(mean(var_intra), 3)), bty="n")
K = 10
variance_nc = NULL
for(k in 1:K){
res.class <- kmeans(X, centers = k)
var_intra = NULL
for(j in 1:k){
var_intra <- c(var_intra, mean(as.matrix(dist(rbind(res.class$centers[j,],
X[which(res.class$cluster==j),])))[-1,1]))
}
variance_nc <- c(variance_nc, mean(var_intra))
}
plot(1:10, variance_nc, type='l', xlab = "nb de classes", ylab="Inertie")
layout(matrix(c(1,2, 3), nrow=1))
plot(X[,c(1,2)], xlab ="x", ylab="y", pch=16, main="Population totale")
plot(X[,c(1,2)], xlab ="x", ylab="y", col = rep(c("firebrick", "cornflowerblue", "purple"), each=100), pch=16, main="Groupes reels")
plot(X[,c(1,2)], xlab ="x", ylab="y", col = kmeans(X, centers = 3)$cluster, pch=16, main="Groupes estimés")
layout(matrix(c(1,2, 3), nrow=1))
plot(X[,c(1,2)], xlab ="x", ylab="y", pch=16, main="Population totale")
plot(X[,c(1,2)], xlab ="x", ylab="y", col = rep(c("firebrick", "cornflowerblue", "purple"), each=100), pch=16, main="Groupes reels")
plot(X[,c(1,2)], xlab ="x", ylab="y", col = kmeans(X, centers = 3)$cluster, pch=16, main="Groupes estimés par le kmeans")
layout(matrix(c(1,2, 3), nrow=1))
plot(X[,c(1,2)], xlab ="x", ylab="y", pch=16, main="Population totale")
plot(X[,c(1,2)], xlab ="x", ylab="y", col = rep(c("firebrick", "cornflowerblue", "purple"), each=100), pch=16, main="Groupes reels")
plot(X[,c(1,2)], xlab ="x", ylab="y", col = kmeans(X, centers = 3)$cluster, pch=16, main="Groupes estimés par le `kmeans`")
layout(matrix(c(1,2, 3), nrow=1))
plot(X[,c(1,2)], xlab ="x", ylab="y", pch=16, main="Population totale")
plot(X[,c(1,2)], xlab ="x", ylab="y", col = rep(c("firebrick", "cornflowerblue", "purple"), each=100), pch=16, main="Groupes reels")
plot(X[,c(1,2)], xlab ="x", ylab="y", col = kmeans(X, centers = 3)$cluster, pch=16, main="Groupes estimés par le kmeans")
