X <- df$Current[which(df$Biome==i)]
Y <- df$Current[which(df$Biome==j)]
print(paste(i, "Versus", j))
print(wilcox.test(X, Y)$p.value*length(unique(df$Biome)))
}
}
}
rm(list=ls()) # Permet de supprimer les objects et fonctions enregister sur l'environnement.
df <- read.table(file = "data/TPs/iron_metabolism_RNA_TP.csv", sep=";", header = T)
load("data/TPs/meta_data.rda")
table(meta_data[,2:3])
n <- length(meta_data$ID) # Nombre d'individus
p <- dim(df)[1] # Nombre de variables
for(i in 1:p){boxplot(as.numeric(df[,-c(1,2)][, meta_data$ID][i,])~as.factor(meta_data$Macro_env), main=(df$SYMBOL)[i])}
p
layout(matrix(c(1:p), nrow = 4, byrow=T))
for(i in 1:p){boxplot(as.numeric(df[,-c(1,2)][, meta_data$ID][i,])~as.factor(meta_data$Micro_env), main=(df$SYMBOL)[i])}
layout(matrix(c(1:p), nrow = 4, byrow=T))
for(i in 1:p){boxplot(as.numeric(df[,-c(1,2)][, meta_data$ID][i,])~as.factor(meta_data$Macro_env), main=(df$SYMBOL)[i])}
layout(matrix(c(1:p), nrow = 4, byrow=T))
for(i in 1:p){boxplot(as.numeric(df[,-c(1,2)][, meta_data$ID][i,])~as.factor(meta_data$Macro_env), main=(df$SYMBOL)[i])}
layout(matrix(c(1:p), nrow = 4, byrow=T))
par(mar=c(4,4,2,2))
for(i in 1:p){boxplot(as.numeric(df[,-c(1,2)][, meta_data$ID][i,])~as.factor(meta_data$Macro_env), main=(df$SYMBOL)[i])}
layout(matrix(c(1:p), nrow = 4, byrow=T))
par(mar=c(2,4,2,2))
for(i in 1:p){boxplot(as.numeric(df[,-c(1,2)][, meta_data$ID][i,])~as.factor(meta_data$Macro_env), main=(df$SYMBOL)[i], xlab="", ylab="ARN expressions")}
layout(matrix(c(1:p), nrow = 4, byrow=T))
par(mar=c(2,4,2,2))
for(i in 1:p){boxplot(as.numeric(df[,-c(1,2)][, meta_data$ID][i,])~as.factor(meta_data$Micro_env), main=(df$SYMBOL)[i], xlab="", ylab="ARN expressions")}
length(which(birds$altitude>(mean(birds$altitude)-2*sd(birds$altitude))&
birds$altitude<(mean(birds$altitude)+2*sd(birds$altitude))))/length(birds$altitude)
load(file = "data/Birds_dataset.rda")
knitr::kable(head(birds))
# Représenter la variable d'altitude.
hist(birds$altitude, col="lightblue", xlab="Altitude (mètres)",ylim=c(0,8),
ylab="Comptage", main="Histogramme de l'altitude des sites")
# Représentation du paramètre de position.
abline(v=mean(birds$altitude), col='red', lwd=2)
abline(v=median(birds$altitude), col="blue", lwd=2)
# Représentation du paramètre de dispersion.
segments(x0 = mean(birds$altitude) - sd(birds$altitude),
x1 = mean(birds$altitude) + sd(birds$altitude),
y0 = 7.5, col="darkolivegreen", lwd=2)
# On ajoute une légende pour comprendre notre graphique.
legend("topleft", col=c("darkolivegreen","red","blue"), lty=1, legend = c("sd", "mean", "median"),
lwd=2, bty="n")
length(which(birds$altitude>(mean(birds$altitude)-2*sd(birds$altitude))&
birds$altitude<(mean(birds$altitude)+2*sd(birds$altitude))))/length(birds$altitude)
ecart_type <- sd(birds$altitude) # définir l'écart-type
condition_moins_ecartT <- which(birds$altitude < (mean(birds$altitude) + (2*ecart_type))) # renvoie l'ensemble des obsevrations pour lequel la condition suivant est respecté : obs INFÉRIEURE à la moyenne + ou - 2 SD.
condition_plus_ecartT <- which(birds$altitude > (mean(birds$altitude) + (2*ecart_type))) # renvoie l'ensemble des obsevrations pour lequel la condition suivant est respecté : obs SUPÉRIEURE à la moyenne + ou - 2 SD.
length(condition_moins_ecartT & condition_plus_ecartT)
length(condition_moins_ecartT & condition_plus_ecartT) /length(birds$altitude)
condition_moins_ecartT
condition_plus_ecartT
condition_moins_ecartT
length(condition_moins_ecartT | condition_plus_ecartT) /length(birds$altitude)
ecart_type <- sd(birds$altitude) # définir l'écart-type
condition_moins_ecartT <- which(birds$altitude < (mean(birds$altitude) + (2*ecart_type))) # renvoie l'ensemble des obsevrations pour lequel la condition suivant est respecté : obs INFÉRIEURE à la moyenne + ou - 2 SD.
condition_plus_ecartT <- which(birds$altitude > (mean(birds$altitude) + (2*ecart_type))) # renvoie l'ensemble des obsevrations pour lequel la condition suivant est respecté : obs SUPÉRIEURE à la moyenne + ou - 2 SD.
length(condition_moins_ecartT | condition_plus_ecartT) / # renvoie le nombre d'observation qui respecte les deux conditions précédentes.
length(birds$altitude) # diviser par le nombre total d'observations.
layout(matrix(c(1,2), nrow=1))
par(mar=c(5,5,2,2)) # Gérer les marges du plot.
# PLOT N°1
boxplot(birds$Medium.dependency,birds$High.Dependency, names = c("Moyenne", 'Élevée'), xlab='Niveau de dependance',
ylab="Richesse d'oiseaux (diversité)")
# PLOT N°2
plot(birds$altitude, birds$Medium.dependency+birds$High.Dependency,
xlab="Altitude (mètres)", ylab="Abondance d'oiseaux\n(Richesse)", main="")
par(mar=c(5,5,2,2)) # Gérer les marges du plot.
# Il faut d'abord normaliser les données pour pouvoir les comparer entre elles
# Plusieurs normalisation existe, ici nous normaliserons les données par rapport à leur maximum.
max.norm.M <- birds$Medium.dependency/max(birds$Medium.dependency)
max.norm.H <- birds$High.Dependency/max(birds$High.Dependency)
plot(birds$altitude, max.norm.M, xlab="Altitude (mètres)", ylab="Abondance d'oiseaux\n(Richesse)",
main="", pch =15, col="darkgreen", ylim=range(c(max.norm.M,max.norm.H)))
points(birds$altitude, max.norm.H, pch=16, col="gold")
# Ajouter la légende.
legend("bottomleft", legend = c("Moyenne", "Élevée"), title="Niveau de Dépendance", pch=c(15,16), col=c("darkgreen", "gold"), bty="n")
shapiro.test(Etude)
load(file = "data/Birds_dataset.rda")
knitr::kable(head(birds))
# Représenter la variable d'altitude.
hist(birds$altitude, col="lightblue", xlab="Altitude (mètres)",ylim=c(0,8),
ylab="Comptage", main="Histogramme de l'altitude des sites")
# Représentation du paramètre de position.
abline(v=mean(birds$altitude), col='red', lwd=2)
abline(v=median(birds$altitude), col="blue", lwd=2)
# Représentation du paramètre de dispersion.
segments(x0 = mean(birds$altitude) - sd(birds$altitude),
x1 = mean(birds$altitude) + sd(birds$altitude),
y0 = 7.5, col="darkolivegreen", lwd=2)
# On ajoute une légende pour comprendre notre graphique.
legend("topleft", col=c("darkolivegreen","red","blue"), lty=1, legend = c("sd", "mean", "median"),
lwd=2, bty="n")
ecart_type <- sd(birds$altitude) # définir l'écart-type
condition_moins_ecartT <- which(birds$altitude < (mean(birds$altitude) + (2*ecart_type))) # renvoie l'ensemble des obsevrations pour lequel la condition suivant est respecté : obs INFÉRIEURE à la moyenne + ou - 2 SD.
condition_plus_ecartT <- which(birds$altitude > (mean(birds$altitude) + (2*ecart_type))) # renvoie l'ensemble des obsevrations pour lequel la condition suivant est respecté : obs SUPÉRIEURE à la moyenne + ou - 2 SD.
length(condition_moins_ecartT | condition_plus_ecartT) / # renvoie le nombre d'observation qui respecte les deux conditions précédentes.
length(birds$altitude) # diviser par le nombre total d'observations.
layout(matrix(c(1,2), nrow=1))
par(mar=c(5,5,2,2)) # Gérer les marges du plot.
# PLOT N°1
boxplot(birds$Medium.dependency,birds$High.Dependency, names = c("Moyenne", 'Élevée'), xlab='Niveau de dependance',
ylab="Richesse d'oiseaux (diversité)")
# PLOT N°2
plot(birds$altitude, birds$Medium.dependency+birds$High.Dependency,
xlab="Altitude (mètres)", ylab="Abondance d'oiseaux\n(Richesse)", main="")
par(mar=c(5,5,2,2)) # Gérer les marges du plot.
# Il faut d'abord normaliser les données pour pouvoir les comparer entre elles
# Plusieurs normalisation existe, ici nous normaliserons les données par rapport à leur maximum.
max.norm.M <- birds$Medium.dependency/max(birds$Medium.dependency)
max.norm.H <- birds$High.Dependency/max(birds$High.Dependency)
plot(birds$altitude, max.norm.M, xlab="Altitude (mètres)", ylab="Abondance d'oiseaux\n(Richesse)",
main="", pch =15, col="darkgreen", ylim=range(c(max.norm.M,max.norm.H)))
points(birds$altitude, max.norm.H, pch=16, col="gold")
# Ajouter la légende.
legend("bottomleft", legend = c("Moyenne", "Élevée"), title="Niveau de Dépendance", pch=c(15,16), col=c("darkgreen", "gold"), bty="n")
layout(matrix(c(1:4), nrow=1, byrow = T))
Etude <- birds$altitude
Colombie <- c(rnorm(250, 2000, 700))
hist(Etude, main="Fonction de densité (Etude, X)", xlab="altitude")
qqnorm(Etude)
qqline(Etude)
hist(Colombie, main="Fonction de densité (Colombie, Y)", xlab="altitude")
qqnorm(Colombie)
qqline(Colombie)
shapiro.test(Etude)
shapiro.test(Colombie)
load(file = "data/Birds_dataset.rda")
knitr::kable(head(birds))
# Représenter la variable d'altitude.
hist(birds$altitude, col="lightblue", xlab="Altitude (mètres)",ylim=c(0,8),
ylab="Comptage", main="Histogramme de l'altitude des sites")
# Représentation du paramètre de position.
abline(v=mean(birds$altitude), col='red', lwd=2)
abline(v=median(birds$altitude), col="blue", lwd=2)
# Représentation du paramètre de dispersion.
segments(x0 = mean(birds$altitude) - sd(birds$altitude),
x1 = mean(birds$altitude) + sd(birds$altitude),
y0 = 7.5, col="darkolivegreen", lwd=2)
# On ajoute une légende pour comprendre notre graphique.
legend("topleft", col=c("darkolivegreen","red","blue"), lty=1, legend = c("sd", "mean", "median"),
lwd=2, bty="n")
ecart_type <- sd(birds$altitude) # définir l'écart-type
condition_moins_ecartT <- which(birds$altitude < (mean(birds$altitude) + (2*ecart_type))) # renvoie l'ensemble des obsevrations pour lequel la condition suivant est respecté : obs INFÉRIEURE à la moyenne + ou - 2 SD.
condition_plus_ecartT <- which(birds$altitude > (mean(birds$altitude) + (2*ecart_type))) # renvoie l'ensemble des obsevrations pour lequel la condition suivant est respecté : obs SUPÉRIEURE à la moyenne + ou - 2 SD.
length(condition_moins_ecartT | condition_plus_ecartT) / # renvoie le nombre d'observation qui respecte les deux conditions précédentes.
length(birds$altitude) # diviser par le nombre total d'observations.
layout(matrix(c(1,2), nrow=1))
par(mar=c(5,5,2,2)) # Gérer les marges du plot.
# PLOT N°1
boxplot(birds$Medium.dependency,birds$High.Dependency, names = c("Moyenne", 'Élevée'), xlab='Niveau de dependance',
ylab="Richesse d'oiseaux (diversité)")
# PLOT N°2
plot(birds$altitude, birds$Medium.dependency+birds$High.Dependency,
xlab="Altitude (mètres)", ylab="Abondance d'oiseaux\n(Richesse)", main="")
par(mar=c(5,5,2,2)) # Gérer les marges du plot.
# Il faut d'abord normaliser les données pour pouvoir les comparer entre elles
# Plusieurs normalisation existe, ici nous normaliserons les données par rapport à leur maximum.
max.norm.M <- birds$Medium.dependency/max(birds$Medium.dependency)
max.norm.H <- birds$High.Dependency/max(birds$High.Dependency)
plot(birds$altitude, max.norm.M, xlab="Altitude (mètres)", ylab="Abondance d'oiseaux\n(Richesse)",
main="", pch =15, col="darkgreen", ylim=range(c(max.norm.M,max.norm.H)))
points(birds$altitude, max.norm.H, pch=16, col="gold")
# Ajouter la légende.
legend("bottomleft", legend = c("Moyenne", "Élevée"), title="Niveau de Dépendance", pch=c(15,16), col=c("darkgreen", "gold"), bty="n")
layout(matrix(c(1:4), nrow=1, byrow = T))
Etude <- birds$altitude
Colombie <- c(rnorm(250, 2000, 700))
hist(Etude, main="Fonction de densité (Etude, X)", xlab="altitude")
qqnorm(Etude)
qqline(Etude)
hist(Colombie, main="Fonction de densité (Colombie, Y)", xlab="altitude")
qqnorm(Colombie)
qqline(Colombie)
shapiro.test(Etude)
shapiro.test(Colombie)
boxplot(Etude, Colombie, names = c("Etude (X)", "Colombie (Y)"), ylab="Altitude",
xlab="Echantillon versus Population", col=c("firebrick", "cornflowerblue"))
legend("topleft", legend = c(round(sd(Etude), 0),round(sd(Colombie), 0)), fill=c("firebrick", "cornflowerblue"), bty="n", cex=0.8, title = "écart-types")
boxplot(Etude, Colombie, names = c("Etude (E)", "Colombie (P)"), ylab="Altitude",
xlab="Echantillon versus Population", col=c("firebrick", "cornflowerblue"))
legend("topleft", legend = c(round(sd(Etude), 0),round(sd(Colombie), 0)), fill=c("firebrick", "cornflowerblue"), bty="n", cex=0.8, title = "écart-types")
var.test(Etude, Colombie)
question("What number is the letter A in the English alphabet?",
answer("8"),
answer("14"),
answer("1", correct = TRUE),
answer("23")
)
install.packages("question")
help(question)
install.packages("questionr")
library(questionr)
question("What number is the letter A in the English alphabet?",
answer("8"),
answer("14"),
answer("1", correct = TRUE),
answer("23")
)
set.seed(1)
boxplot(rnorm(10), rnorm(10, 1))
set.seed(1)
boxplot(rnorm(10), rnorm(10, 0.5))
plot(rnorm(10), rnorm(10, 0.5))
et.seed(1)
set.seed(1)
plot(x = rep(c(1,2), 4) rnorm(4), rnorm(4, 0.5))
plot(x = rep(c(1,2), 4),y= c(rnorm(4), rnorm(4, 0.5)))
set.seed(1)
plot(x = rep(c(1,2), 5),y= c(rnorm(5), rnorm(5, 0.5)))
set.seed(1)
plot(x = rep(c(1,2), 5),y= c(rnorm(5), rnorm(5, 0.5)), xlab="", ylab="")
set.seed(1)
plot(x = rep(c(1,2), 5),y= c(rnorm(5), rnorm(5, 0.5)), xlab="", ylab="")
set.seed(1)
plot(x = rep(c(1,2), 5),y= c(rnorm(5), rnorm(5, 0.5)), xlab="", ylab="")
set.seed(1)
plot(x = rep(c(1,2), 5),y= c(rnorm(5), rnorm(5, 0.5)), xlab="", ylab="")
set.seed(1)
boxplot(rnorm(10), rnorm(10, 0.5))
set.seed(1)
boxplot(rnorm(10), rnorm(10, 0.5))
1+3+5+7+9
2+4+6+8+10
data.frame(Group = as.factor(rep(c(1,2), 5)), value = c(rnorm(5), rnorm(5, 0.5)))
set.seed(1)
data.frame(Group = as.factor(rep(c(1,2), 5)), value = c(rnorm(5), rnorm(5, 0.5)))
plot(x = ,y= c(rnorm(5), rnorm(5, 0.5)), xlab="", ylab="")
set.seed(1)
df = data.frame(Group = as.factor(rep(c(1,2), 5)), value = c(rnorm(5), rnorm(5, 0.5)))
plot(df$Group, df$value, xlab="", ylab="")
set.seed(1)
df = data.frame(Group = rep(c(1,2), 5), value = c(rnorm(5), rnorm(5, 0.5)))
plot(df$Group, df$value, xlab="", ylab="")
wilcox.test(df$value~df$Group)
set.seed(1)
df = data.frame(Group = rep(c(1,2), 5), value = c(rnorm(5), rnorm(5, 0.8)))
plot(df$Group, df$value, xlab="", ylab="")
wilcox.test(df$value~df$Group)
set.seed(1)
df = data.frame(Group = rep(c(1,2), 5), value = c(rnorm(5), rnorm(5, 1)))
plot(df$Group, df$value, xlab="", ylab="")
wilcox.test(df$value~df$Group)
set.seed(1)
df = data.frame(Group = rep(c(1,2), 5), value = c(rnorm(5), rnorm(5, 1)))
plot(df$Group, df$value, xlab="", ylab="")
wilcox.test(df$value~df$Group)
set.seed(1)
df = data.frame(Group = rep(c(1,2), 5), value = c(rnorm(5), rnorm(5, 1.5)))
plot(df$Group, df$value, xlab="", ylab="")
wilcox.test(df$value~df$Group)
df$Group
set.seed(1)
df = data.frame(Group = rep(c(1,2), each = 5), value = c(rnorm(5), rnorm(5, 1.5)))
plot(df$Group, df$value, xlab="", ylab="")
wilcox.test(df$value~df$Group)
wilcox.test(df$value~df$Group)
set.seed(1)
df = data.frame(Group = rep(c(1,2), each = 5), value = c(rnorm(5), rnorm(5, 0.8)))
plot(df$Group, df$value, xlab="", ylab="")
wilcox.test(df$value~df$Group)
set.seed(1)
df = data.frame(Group = rep(c(1,2), each = 5), value = c(rnorm(5), rnorm(5, 0.9)))
plot(df$Group, df$value, xlab="", ylab="")
wilcox.test(df$value~df$Group)
set.seed(1)
df = data.frame(Group = rep(c(1,2), each = 5), value = c(rnorm(5), rnorm(5, 01)))
plot(df$Group, df$value, xlab="", ylab="")
wilcox.test(df$value~df$Group)
set.seed(1)
df = data.frame(Group = rep(c(1,2), each = 5), value = c(rnorm(5), rnorm(5, 01.1)))
plot(df$Group, df$value, xlab="", ylab="")
wilcox.test(df$value~df$Group)
rang(df$value)
rangs(df$value)
rank(df$value)
rank(df$value)~df$Group
rank(df$value)[which(df$Group==1)]
rank(df$value)[which(df$Group==1)]
rank(df$value)[which(df$Group==1)]
paste("la somme des rangs pour le groupe 1 est de", sum(rank(df$value)[which(df$Group==1)]))
wilcox.test(df$value~df$Group)
Colombian_birds <- (birds$Medium.dependency+birds$High.Dependency)+rnorm(22,0, 1)
load(file = "data/Birds_dataset.rda")
knitr::kable(head(birds))
# Représenter la variable d'altitude.
hist(birds$altitude, col="lightblue", xlab="Altitude (mètres)",ylim=c(0,8),
ylab="Comptage", main="Histogramme de l'altitude des sites")
# Représentation du paramètre de position.
abline(v=mean(birds$altitude), col='red', lwd=2)
abline(v=median(birds$altitude), col="blue", lwd=2)
# Représentation du paramètre de dispersion.
segments(x0 = mean(birds$altitude) - sd(birds$altitude),
x1 = mean(birds$altitude) + sd(birds$altitude),
y0 = 7.5, col="darkolivegreen", lwd=2)
# On ajoute une légende pour comprendre notre graphique.
legend("topleft", col=c("darkolivegreen","red","blue"), lty=1, legend = c("sd", "mean", "median"),
lwd=2, bty="n")
ecart_type <- sd(birds$altitude) # définir l'écart-type
condition_moins_ecartT <- which(birds$altitude < (mean(birds$altitude) + (2*ecart_type))) # renvoie l'ensemble des obsevrations pour lequel la condition suivant est respecté : obs INFÉRIEURE à la moyenne + ou - 2 SD.
condition_plus_ecartT <- which(birds$altitude > (mean(birds$altitude) + (2*ecart_type))) # renvoie l'ensemble des obsevrations pour lequel la condition suivant est respecté : obs SUPÉRIEURE à la moyenne + ou - 2 SD.
length(condition_moins_ecartT | condition_plus_ecartT) / # renvoie le nombre d'observation qui respecte les deux conditions précédentes.
length(birds$altitude) # diviser par le nombre total d'observations.
layout(matrix(c(1,2), nrow=1))
par(mar=c(5,5,2,2)) # Gérer les marges du plot.
# PLOT N°1
boxplot(birds$Medium.dependency,birds$High.Dependency, names = c("Moyenne", 'Élevée'), xlab='Niveau de dependance',
ylab="Richesse d'oiseaux (diversité)")
# PLOT N°2
plot(birds$altitude, birds$Medium.dependency+birds$High.Dependency,
xlab="Altitude (mètres)", ylab="Abondance d'oiseaux\n(Richesse)", main="")
par(mar=c(5,5,2,2)) # Gérer les marges du plot.
# Il faut d'abord normaliser les données pour pouvoir les comparer entre elles
# Plusieurs normalisation existe, ici nous normaliserons les données par rapport à leur maximum.
max.norm.M <- birds$Medium.dependency/max(birds$Medium.dependency)
max.norm.H <- birds$High.Dependency/max(birds$High.Dependency)
plot(birds$altitude, max.norm.M, xlab="Altitude (mètres)", ylab="Abondance d'oiseaux\n(Richesse)",
main="", pch =15, col="darkgreen", ylim=range(c(max.norm.M,max.norm.H)))
points(birds$altitude, max.norm.H, pch=16, col="gold")
# Ajouter la légende.
legend("bottomleft", legend = c("Moyenne", "Élevée"), title="Niveau de Dépendance", pch=c(15,16), col=c("darkgreen", "gold"), bty="n")
layout(matrix(c(1:4), nrow=1, byrow = T))
Etude <- birds$altitude
Colombie <- c(rnorm(250, 2000, 700))
hist(Etude, main="Fonction de densité (Etude, X)", xlab="altitude")
qqnorm(Etude)
qqline(Etude)
hist(Colombie, main="Fonction de densité (Colombie, Y)", xlab="altitude")
qqnorm(Colombie)
qqline(Colombie)
shapiro.test(Etude)
shapiro.test(Colombie)
boxplot(Etude, Colombie, names = c("Etude (E)", "Colombie (P)"), ylab="Altitude",
xlab="Echantillon versus Population", col=c("firebrick", "cornflowerblue"))
legend("topleft", legend = c(round(sd(Etude), 0),round(sd(Colombie), 0)), fill=c("firebrick", "cornflowerblue"), bty="n", cex=0.8, title = "écart-types")
var.test(Etude, Colombie)
n_x <- length(Etude) # on enregistre le nombre d'observations dans X
n_y <- length(Colombie) # on enregistre le nombre d'observations dans Y
## On calcul les variances
var_x <- var(Etude) # on enregistre la variance de X
var_y <- var(Colombie) # on enregistre la variance de Y
## On calcul les moyennes
mu_x <- mean(Etude)
mu_y <- mean(Colombie)
## On calcul la variance poolée
S2_P <- ((n_x-1)*var_x + (n_y-1)*var_y)/(n_x+n_y-2)
## On peut finalement calculer la Statistique T
S_T = (mu_x-mu_y) / sqrt(S2_P/(n_x-1) + S2_P/(n_y-1))
print(S_T)
loi_de_student <- rt(500, 270)
hist(loi_de_student, main="Densité d'une loi de Student", xlab="") # On construit une loi de student pour replacer notre statistique de T et calculer sa probabilité (i.e. sa rareté).
abline(v=S_T)
text(x=S_T+0.25,y=50 , "Statistique T\nde notre test", adj=0, xpd="NA")
length(which(loi_de_student>S_T))/500
## On peut aussi calculer la probabilité d'observer la statistique T calculée directement avec la fonction de probabilité.
1-pt(S_T ,270)
t.test(Etude, Colombie, var.equal = T)
Colombian_birds <- (birds$Medium.dependency+birds$High.Dependency)+rnorm(22,0, 1)
French_birds <- c(rnorm(10, 200, 50),rnorm(10, 250, 10))
df <- data.frame(Pays = c(rep("Colombie", length(Colombian_birds)),rep("France", length(French_birds))) ,
diversity = c(Colombian_birds, French_birds))
R_x <- sum(rank(df$diversity)[which(df$Pays=="France")]) # On récupère la somme des rangs associées au oiseaux de la France.
paste('la statistique du test de wilcoxon est de : w = ',22*20+((20*(20+1))/2)-R_x)
wilcox.test(diversity~Pays, data=df)
wilcox.test(df$value~df$Group)
load(file = "data/Birds_dataset.rda")
knitr::kable(head(birds))
# Représenter la variable d'altitude.
hist(birds$altitude, col="lightblue", xlab="Altitude (mètres)",ylim=c(0,8),
ylab="Comptage", main="Histogramme de l'altitude des sites")
# Représentation du paramètre de position.
abline(v=mean(birds$altitude), col='red', lwd=2)
abline(v=median(birds$altitude), col="blue", lwd=2)
# Représentation du paramètre de dispersion.
segments(x0 = mean(birds$altitude) - sd(birds$altitude),
x1 = mean(birds$altitude) + sd(birds$altitude),
y0 = 7.5, col="darkolivegreen", lwd=2)
# On ajoute une légende pour comprendre notre graphique.
legend("topleft", col=c("darkolivegreen","red","blue"), lty=1, legend = c("sd", "mean", "median"),
lwd=2, bty="n")
ecart_type <- sd(birds$altitude) # définir l'écart-type
condition_moins_ecartT <- which(birds$altitude < (mean(birds$altitude) + (2*ecart_type))) # renvoie l'ensemble des obsevrations pour lequel la condition suivant est respecté : obs INFÉRIEURE à la moyenne + ou - 2 SD.
condition_plus_ecartT <- which(birds$altitude > (mean(birds$altitude) + (2*ecart_type))) # renvoie l'ensemble des obsevrations pour lequel la condition suivant est respecté : obs SUPÉRIEURE à la moyenne + ou - 2 SD.
length(condition_moins_ecartT | condition_plus_ecartT) / # renvoie le nombre d'observation qui respecte les deux conditions précédentes.
length(birds$altitude) # diviser par le nombre total d'observations.
layout(matrix(c(1,2), nrow=1))
par(mar=c(5,5,2,2)) # Gérer les marges du plot.
# PLOT N°1
boxplot(birds$Medium.dependency,birds$High.Dependency, names = c("Moyenne", 'Élevée'), xlab='Niveau de dependance',
ylab="Richesse d'oiseaux (diversité)")
# PLOT N°2
plot(birds$altitude, birds$Medium.dependency+birds$High.Dependency,
xlab="Altitude (mètres)", ylab="Abondance d'oiseaux\n(Richesse)", main="")
par(mar=c(5,5,2,2)) # Gérer les marges du plot.
# Il faut d'abord normaliser les données pour pouvoir les comparer entre elles
# Plusieurs normalisation existe, ici nous normaliserons les données par rapport à leur maximum.
max.norm.M <- birds$Medium.dependency/max(birds$Medium.dependency)
max.norm.H <- birds$High.Dependency/max(birds$High.Dependency)
plot(birds$altitude, max.norm.M, xlab="Altitude (mètres)", ylab="Abondance d'oiseaux\n(Richesse)",
main="", pch =15, col="darkgreen", ylim=range(c(max.norm.M,max.norm.H)))
points(birds$altitude, max.norm.H, pch=16, col="gold")
# Ajouter la légende.
legend("bottomleft", legend = c("Moyenne", "Élevée"), title="Niveau de Dépendance", pch=c(15,16), col=c("darkgreen", "gold"), bty="n")
layout(matrix(c(1:4), nrow=1, byrow = T))
Etude <- birds$altitude
Colombie <- c(rnorm(250, 2000, 700))
hist(Etude, main="Fonction de densité (Etude, X)", xlab="altitude")
qqnorm(Etude)
qqline(Etude)
hist(Colombie, main="Fonction de densité (Colombie, Y)", xlab="altitude")
qqnorm(Colombie)
qqline(Colombie)
shapiro.test(Etude)
shapiro.test(Colombie)
boxplot(Etude, Colombie, names = c("Etude (E)", "Colombie (P)"), ylab="Altitude",
xlab="Echantillon versus Population", col=c("firebrick", "cornflowerblue"))
legend("topleft", legend = c(round(sd(Etude), 0),round(sd(Colombie), 0)), fill=c("firebrick", "cornflowerblue"), bty="n", cex=0.8, title = "écart-types")
var.test(Etude, Colombie)
n_x <- length(Etude) # on enregistre le nombre d'observations dans X
n_y <- length(Colombie) # on enregistre le nombre d'observations dans Y
## On calcul les variances
var_x <- var(Etude) # on enregistre la variance de X
var_y <- var(Colombie) # on enregistre la variance de Y
## On calcul les moyennes
mu_x <- mean(Etude)
mu_y <- mean(Colombie)
## On calcul la variance poolée
S2_P <- ((n_x-1)*var_x + (n_y-1)*var_y)/(n_x+n_y-2)
## On peut finalement calculer la Statistique T
S_T = (mu_x-mu_y) / sqrt(S2_P/(n_x-1) + S2_P/(n_y-1))
print(S_T)
loi_de_student <- rt(500, 270)
hist(loi_de_student, main="Densité d'une loi de Student", xlab="") # On construit une loi de student pour replacer notre statistique de T et calculer sa probabilité (i.e. sa rareté).
abline(v=S_T)
text(x=S_T+0.25,y=50 , "Statistique T\nde notre test", adj=0, xpd="NA")
length(which(loi_de_student>S_T))/500
## On peut aussi calculer la probabilité d'observer la statistique T calculée directement avec la fonction de probabilité.
1-pt(S_T ,270)
t.test(Etude, Colombie, var.equal = T)
Colombian_birds <- (birds$Medium.dependency+birds$High.Dependency)+rnorm(22,0, 1)
French_birds <- c(rnorm(10, 200, 50),rnorm(10, 250, 10))
df <- data.frame(Pays = c(rep("Colombie", length(Colombian_birds)),rep("France", length(French_birds))) ,
diversity = c(Colombian_birds, French_birds))
R_x <- sum(rank(df$diversity)[which(df$Pays=="France")]) # On récupère la somme des rangs associées au oiseaux de la France.
paste('la statistique du test de wilcoxon est de : w = ',22*20+((20*(20+1))/2)-R_x)
wilcox.test(diversity~Pays, data=df)
set.seed(1)
boxplot(rnorm(10), rnorm(10, 0.5))
set.seed(1)
df = data.frame(Group = rep(c(1,2), each = 5), value = c(rnorm(5), rnorm(5, 01.1)))
plot(df$Group, df$value, xlab="", ylab="")
rank(df$value)[which(df$Group==1)]
paste("la somme des rangs pour le groupe 1 est de", sum(rank(df$value)[which(df$Group==1)]))
rank(df$value)[which(df$Group==1)]
paste("la somme des rangs pour le groupe 1 est de", sum(rank(df$value)[which(df$Group==1)]))
wilcox.test(df$value~df$Group)
rank(df$value)[which(df$Group==1)]
paste("la somme des rangs pour le groupe 1 est de", sum(rank(df$value)[which(df$Group==1)]))
wilcox.test(df$value~df$Group)
df <- read.table("~/Dropbox/COURS/UBS/BIO1540/Package n°2/rawdata/heptathlon_2023.csv", sep=",", header=T, stringsAsFactors = T, row.names = 1)
df <- read.table("data/heptathlon_2023.csv", sep=",", header=T, stringsAsFactors = T, row.names = 1)
df <- read.table("data/heptathlon_2023.csv", sep=",", header=T, stringsAsFactors = T, row.names = 1)
layout(matrix(c(1,2), nrow=1))
plot(df$X100m, df$X200m, xlab="100H (s)", ylab="200 (s)", pch=16, col="gray")
plot(df$Longueur, df$X200m,  xlab="Longueur (m)", ylab="200 (s)", pch=16, col="gray")
df <- read.table("data/heptathlon_2023.csv", sep=",", header=T, stringsAsFactors = T, row.names = 1)
head(df)
n <- dim(df)[1]
x_center <- df$X100m-mean(df$X100m)
y_center <- df$X200m-mean(df$X200m)
Covariance <- sum(x_center*y_center)/(n-1)
var_x <- sqrt(sum(x_center^2)/(n-1))
var_y <- sqrt(sum(y_center^2)/(n-1))
r <- Covariance/(var_x*var_y)
print(r)
lm(df$X200m~df$X100m)
lm(df$X200m~df$X100m)
lm(df$X200m~df$X100m)
plot(df$X100m, df$X200m, xlab="100H (s)", ylab="200 (s)", pch=16, col="gray")
points(df$X100m[which(df$X100m>15)],df$X200m[which(df$X100m>15)], col="red", pch=16)
abline(coef(lm(df$X200m~df$X100m)))
plot(df$X100m, df$X200m, xlab="100H (s)", ylab="200 (s)", pch=16, col="gray")
points(df$X100m[which(df$X100m>15)],df$X200m[which(df$X100m>15)], col="red", pch=16)
abline(coef(lm(df$X200m~df$X100m)))
plot(df$X100m, df$X200m, xlab="100H (s)", ylab="200 (s)", pch=16, col="gray")
points(df$X100m[which(df$X100m>15)],df$X200m[which(df$X100m>15)], col="red", pch=16)
abline(coef(lm(df$X200m~df$X100m)))
lm(df$X200m~df$X100m)
model <- lm(df$X200m~df$X100m) ## Nous ajustons un modèle linéaire où la variable réponse est le temps au 200m.
SCT = sum(y_center^2) ## Nous calculons la somme des carrés totale de la variable réponse Y.
SCE = sum(model$residuals^2) ## Puis la somme des carrés non expliquée de la variable réponse Y par X.
r_squared <- 1-(SCE/SCT)
print(r_squared)
r^2
model <- lm(df$X200m~df$X100m)
summary(model)
cor.test(df$X200m,df$X100m, method="pearson")
shapiro.test(df$X100m)
shapiro.test(df$X200m)
df <- read.table("data/heptathlon_2023.csv", sep=",", header=T, stringsAsFactors = T, row.names = 1)
df <- read.table("data/heptathlon_2023.csv", sep=",", header=T, stringsAsFactors = T, row.names = 1)
head(df)
layout(matrix(c(1,2), nrow=1))
plot(df$X100m, df$X200m, xlab="100H (s)", ylab="200 (s)", pch=16, col="gray")
plot(df$Longueur, df$X200m,  xlab="Longueur (m)", ylab="200 (s)", pch=16, col="gray")
plot(df$X100m, df$X200m, xlab="100H (s)", ylab="200 (s)", pch=16, col="gray")
points(df$X100m[which(df$X100m>15)],df$X200m[which(df$X100m>15)], col="red", pch=16)
abline(coef(lm(df$X200m~df$X100m)))
